{
  "title": "WorkManager",
  "content": [
    {
      "type": "text",
      "value": "**WorkManager** — это современный API для управления отложенными и гарантированно выполняемыми фоновыми задачами, даже если приложение закрыто или устройство перезагружается."
    },
    {
      "type": "text",
      "value": "### Основные возможности WorkManager:\n\n**Ключевые особенности**\n\n- **Гарантированное выполнение:** задача выполнится даже при перезагрузке устройства\n\n- **Гибкость:** одноразовые и периодические задачи\n\n- **Условия выполнения:** только при заряде, наличии сети и т.д.\n\n- **Совместимость:** использует разные механизмы в зависимости от версии Android (JobScheduler, AlarmManager, BroadcastReceiver)\n\n- **Интеграция с Jetpack**: работает с LiveData, Coroutines, RxJava\n\n**Когда использовать?**\n\n- Загрузка данных с сервера по расписанию\n\n- Резервное копирование данных\n\n- Периодическая синхронизация\n\n- Отправка логов и аналитики"
    },
    {
      "type": "text",
      "value": "**Лучшие практики**\n\n- **Для критически важных задач** используется **setExpedited()** (Android 12+)\n\n- **Избегайте долгих операций** (>10 минут) — система может прервать\n\n- **Используйте уникальные имена** для периодических задач\n\n- **Тестируйте** с **WorkManagerTestInitHelper**\n\n- **Комбинируйте с AlarmManager** для точного времени (например, будильники)"
    },
    {
      "type": "text",
      "value": "Метод **doWork()** — это место, где выполняется основная логика вашей задачи. Он запускается в фоновом режиме, и его результат определяет, что делать дальше.\n\nМетод **doWork()** должен возвращать объект типа **Result**. Этот объект указывает **WorkManager**, как обработать результат выполнения задачи. Есть три основных варианта:\n\n- **Result.success()** Возвращается, если задача выполнена успешно. WorkManager считает задачу завершенной и больше не будет пытаться ее выполнять.\n\n- **Result.failure()** Возвращается, если задача не выполнена из-за ошибки. WorkManager считает задачу завершенной с ошибкой и больше не будет пытаться ее выполнять.\n\n- **Result.retry()** Возвращается, если задача не выполнена, но ее нужно попробовать выполнить снова позже. **WorkManager** попытается выполнить задачу еще раз через некоторое время (с учетом backoff-стратегии). Если вы возвращаете **Result.retry()**, **WorkManager** попытается выполнить задачу снова через некоторое время. По умолчанию используется экспоненциальная задержка (exponential backoff), чтобы не перегружать систему."
    },
    {
      "type": "text",
      "value": "### Настройка WorkManager:"
    },
    {
      "type": "text",
      "value": "Добавление зависимостей в **build.gradle (Module: app):**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "dependencies {\n    def work_version = \"2.8.1\"\n    \n    // Основная библиотека\n    implementation \"androidx.work:work-runtime-ktx:$work_version\"\n    \n    // Для работы с корутинами\n    implementation \"androidx.work:work-runtime-ktx:$work_version\"\n    \n    // Для RxJava (опционально)\n    implementation \"androidx.work:work-rxjava3:$work_version\"\n}"
    },
    {
      "type": "text",
      "value": "Простейший Worker:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class SimpleWorker(context: Context, params: WorkerParameters) : \n    Worker(context, params) {\n    \n    override fun doWork(): Result {\n        // Фоновая работа\n        Log.d(\"WorkManager\", \"Выполняю работу!\")\n        \n        return Result.success()\n    }\n}"
    },
    {
      "type": "text",
      "value": "Worker с корутинами:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class CoroutineWorker(context: Context, params: WorkerParameters) : \n    CoroutineWorker(context, params) {\n    \n    override suspend fun doWork(): Result {\n        // Асинхронная работа\n        val result = withContext(Dispatchers.IO) {\n            fetchDataFromNetwork()\n        }\n        \n        return if (result.isSuccess) {\n            Result.success()\n        } else {\n            Result.failure()\n        }\n    }\n}"
    },
    {
      "type": "text",
      "value": "### Настройка задач (WorkRequest):"
    },
    {
      "type": "text",
      "value": "**Одноразовая задача:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val oneTimeRequest = OneTimeWorkRequestBuilder<SimpleWorker>()\n    .build()"
    },
    {
      "type": "text",
      "value": "**Периодическая задача:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val periodicRequest = PeriodicWorkRequestBuilder<SimpleWorker>(\n    15, TimeUnit.MINUTES // Минимальный интервал — 15 минут\n).build()"
    },
    {
      "type": "text",
      "value": "**Задача с входными данными:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val data = workDataOf(\n    \"KEY_URL\" to \"https://api.example.com/data\",\n    \"KEY_USER_ID\" to 42\n)\n\nval request = OneTimeWorkRequestBuilder<DataWorker>()\n    .setInputData(data)\n    .build()"
    },
    {
      "type": "text",
      "value": "Получение данных в Worker:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "override fun doWork(): Result {\n    val url = inputData.getString(\"KEY_URL\")\n    val userId = inputData.getInt(\"KEY_USER_ID\", 0)\n    // ...\n}"
    },
    {
      "type": "text",
      "value": "### Условия выполнения:"
    },
    {
      "type": "text",
      "value": "**Ограничения (Constraints):**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED) // Только с интернетом\n    .setRequiresCharging(true) // Только при зарядке\n    .setRequiresBatteryNotLow(true) // Батарея не на низком уровне\n    .build()\n\nval request = OneTimeWorkRequestBuilder<DownloadWorker>()\n    .setConstraints(constraints)\n    .build()"
    },
    {
      "type": "text",
      "value": "**Отложенное выполнение:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val request = OneTimeWorkRequestBuilder<NotificationWorker>()\n    .setInitialDelay(1, TimeUnit.HOURS) // Через 1 час\n    .build()"
    },
    {
      "type": "text",
      "value": "### Управление задачами:"
    },
    {
      "type": "text",
      "value": "**Запуск задачи:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val workManager = WorkManager.getInstance(context)\nworkManager.enqueue(request)"
    },
    {
      "type": "text",
      "value": "**Цепочки задач:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val chain = workManager\n    .beginWith(workRequestA)\n    .then(workRequestB) // Выполнится после успеха A\n    .then(workRequestC) // Выполнится после успеха B\n    .enqueue()"
    },
    {
      "type": "text",
      "value": "**Параллельные задачи:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val parallelWork = mutableListOf<OneTimeWorkRequest>()\nparallelWork.add(workRequest1)\nparallelWork.add(workRequest2)\n\nworkManager\n    .beginWith(parallelWork)\n    .then(workRequest3)\n    .enqueue()"
    },
    {
      "type": "text",
      "value": "### Наблюдение за состоянием"
    },
    {
      "type": "text",
      "value": "**Получение информации о работе:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "workManager.getWorkInfoByIdLiveData(request.id)\n    .observe(this) { info ->\n        when (info?.state) {\n            WorkInfo.State.ENQUEUED -> { /* В очереди */ }\n            WorkInfo.State.RUNNING -> { /* Выполняется */ }\n            WorkInfo.State.SUCCEEDED -> { /* Успешно */ }\n            WorkInfo.State.FAILED -> { /* Ошибка */ }\n            WorkInfo.State.CANCELLED -> { /* Отменено */ }\n        }\n    }"
    },
    {
      "type": "text",
      "value": "**Результаты работы:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "workManager.getWorkInfoByIdLiveData(request.id)\n    .observe(this) { info ->\n        if (info?.state == WorkInfo.State.SUCCEEDED) {\n            val result = info.outputData.getString(\"RESULT_KEY\")\n            // Обработка результата\n        }\n    }"
    },
    {
      "type": "text",
      "value": "Отправка результата из Worker:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "override fun doWork(): Result {\n    val output = workDataOf(\"RESULT_KEY\" to \"Данные успешно загружены\")\n    return Result.success(output)\n}"
    },
    {
      "type": "text",
      "value": "### Отмена задач:"
    },
    {
      "type": "text",
      "value": "**По ID:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "workManager.cancelWorkById(request.id)"
    },
    {
      "type": "text",
      "value": "**По тегу:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "workManager.cancelAllWorkByTag(\"SYNC_TAG\")"
    },
    {
      "type": "text",
      "value": "**Все задачи:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "workManager.cancelAllWork()"
    },
    {
      "type": "text",
      "value": "### Пример: загрузка данных с сервера:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class SyncWorker(context: Context, params: WorkerParameters) : \n    CoroutineWorker(context, params) {\n\n    override suspend fun doWork(): Result {\n        return try {\n            val api = RetrofitClient.create()\n            val response = api.getData()\n            \n            if (response.isSuccessful) {\n                saveToDatabase(response.body()!!)\n                Result.success()\n            } else {\n                Result.failure()\n            }\n        } catch (e: Exception) {\n            Result.retry() // Попробует снова\n        }\n    }\n}\n\n// Запуск раз в день\nval constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .build()\n\nval request = PeriodicWorkRequestBuilder<SyncWorker>(\n    1, TimeUnit.DAYS\n).setConstraints(constraints)\n .build()\n\nWorkManager.getInstance(context).enqueueUniquePeriodicWork(\n    \"DAILY_SYNC\",\n    ExistingPeriodicWorkPolicy.KEEP,\n    request\n)"
    }
  ]
}