{
  "title": "Коорутины: теория",
  "content": [
    {
      "type": "text",
      "value": "**Корутина** — это легковесная \"задача\", которая может **приостанавливаться (suspend)** и **возобновляться** без блокировки потока."
    },
    {
      "type": "text",
      "value": "- **Корутины** позволяют выполнять асинхронные операции, которые могут быть приостановлены, а позже продолжить свое выполнение.\n\n\n\n- **Корутины это не потоки** - потоки применяются для организации многозадачности, корутины же представляют **асинхронные** операции, но они выполняются параллельно.\n\n- Преимущество перед потоками - легкость переключения между ними.\n\n- **Корутины** используют заданные пулы потоков, что позволяет выполнять множество задач. \n\n- **Корутина** может выполняется в нескольких поток потоках.\n\n- Вместо блокировки **корутины** приостанавливаются и высвобождают свой ресурс для других операций. \n\n\n\n- **Корутины** - это возможность писать асинхронный код в синхронном стиле.\n\n- **Корутины** дают возможность использовать меньше кода и меньше классов, а такой подход позволят приложению создавать меньше объектов в памяти."
    },
    {
      "type": "text",
      "value": "**Используйте корутины для:**\n\n- Сетевых запросов\n\n- Работы с БД\n\n- Фоновых задач в Android\n\n- Асинхронных операций\n\n**Используйте потоки для:**\n\n- CPU-intensive вычислений\n\n- Работы с нативным кодом\n\n- Когда нужен низкоуровневый контроль"
    },
    {
      "type": "text",
      "value": "### Чем отличаются корутины от потоков:"
    },
    {
      "type": "text",
      "value": "**Вес и стоимость:**"
    },
    {
      "type": "text",
      "value": "- Потоки - тяжелые. Поток: ~1-2MB памяти"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "Thread { /* работа */ } // ~1MB памяти, дорого создавать"
    },
    {
      "type": "text",
      "value": "- Корутины - легкие. Корутина: ~0.1-1KB памяти"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "launch { /* работа */ } // ~几十KB, можно тысячи"
    },
    {
      "type": "text",
      "value": "Можно создать **тысячи** корутин vs **десятки** потоков"
    },
    {
      "type": "text",
      "value": "**Блокировка vs Приостановка:**"
    },
    {
      "type": "text",
      "value": "- Поток блокирует:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "Thread {\n    val data = networkRequest() // Поток БЛОКИРУЕТСЯ и ждет\n    updateUI(data)\n}"
    },
    {
      "type": "text",
      "value": "- Коорутина приостанавливает :"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "launch {\n    val data = networkRequest() // Корутина ПРИОСТАНАВЛИВАЕТСЯ\n    updateUI(data)              // Поток ОСВОБОЖДАЕТСЯ для других задач\n}"
    },
    {
      "type": "text",
      "value": "**Управление:**\n\n- **Потоки** управляются ОС\n\n- **Корутины** управляются программистом (когда приостанавливать, когда возобновлять)"
    },
    {
      "type": "text",
      "value": "### Преимущества корутин:"
    },
    {
      "type": "text",
      "value": "- Эффективность памяти\n\n а) 1000 корутин ≠ 1000 потоков\n\n б) 1000 корутин могут работать в нескольких потоках (например, в 4)"
    },
    {
      "type": "text",
      "value": "- Упрощение асинхронного кода"
    },
    {
      "type": "text",
      "value": "- Отмена и таймауты"
    },
    {
      "type": "text",
      "value": "- Структурированный параллелизм"
    },
    {
      "type": "text",
      "value": "### Недостатки корутин"
    },
    {
      "type": "text",
      "value": "- Не для всех задач\n\n а) CPU-intensive задачи лучше в потоках\n\n б) Нативные библиотеки могут не поддерживать корутины"
    },
    {
      "type": "text",
      "value": "- Меньше контроля низкого уровня\n\n а) Потоки дают больше контроля над планированием\n\n б) Корутины абстрагируют управление потоками"
    },
    {
      "type": "text",
      "value": "### Жизненный цикл корутин"
    },
    {
      "type": "text",
      "value": "**Жизненный цикл корутины** — это её состояние от создания до завершения."
    },
    {
      "type": "image",
      "src": "/images/android/android_coroutine_life_cycle.png",
      "alt": "Жизеннный цикл корутины",
      "caption": "Жизеннный цикл корутины"
    },
    {
      "type": "text",
      "value": "- New\n\n- **Active** - работает\n\n- **Completing** - успешно завершилась\n\n- Cancelling\n\n- **Canselled** - отменена (вручную или из-за ошибки)\n\n- Completed"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val job = launch {\n    // Состояние: Active\n    doWork()\n    // После выполнения: Completed\n}\n\njob.cancel() // Переход в Cancelled"
    },
    {
      "type": "text",
      "value": "### coroutineScope()"
    },
    {
      "type": "text",
      "value": "**coroutineScope()** — это функция, которая создает новую область видимости для корутин. Проще говоря, это функция для структурированного параллелизма:"
    },
    {
      "type": "text",
      "value": "**Особенности:**"
    },
    {
      "type": "text",
      "value": "- Хранит все ссылки на корутину\n\n - Может отменить выполнение всех дочерних корутин, если возникнет ошибка, или операция будет отменена.\n\n - Знает все про корутины - любая корутина хранится ссылкой в нем.\n\n - Автоматически ожидает выполнения всех дочерних корутин, но не обязательно завершается вместе с ними."
    },
    {
      "type": "text",
      "value": "**CoroutineScope** выполниться успешно, когда будут завершены все корутины и дочерные Scope внутри него.\n\n\n\n Любой **CoroutineScope** является активным со старта. Что бы его уничтожить, нужно явно вызвать CoroutineScope.cancel(cause: CancellationExeption? = null), которая остановить все запущенные в нем корутины."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Родительская корутина - как учитель в классе\nsuspend fun teacherWork() = coroutineScope {\n    // Дети - корутины\n    launch { student1Homework() }\n    launch { student2Homework() }\n    \n    // Учитель ждет, пока ВСЕ дети закончат\n    // Если один ребенок ошибся - все останавливаются\n}"
    },
    {
      "type": "text",
      "value": "`.launch()` - \"Запусти и забудь\""
    },
    {
      "type": "text",
      "value": "**Когда использовать:**\n\n- Сохранение данных\n\n- Логирование\n\n- Фоновые задачи"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Для операций, которые не возвращают результат\nval job = launch {\n    saveDataToDatabase() // Просто выполняем работу\n    // Ничего не возвращаем\n}\n\n// Управляем через Job\njob.cancel()"
    },
    {
      "type": "text",
      "value": "`.async()` - \"Запусти и верни результат\""
    },
    {
      "type": "text",
      "value": "**Когда использовать:**\n\n- Сетевые запросы\n\n- Вычисления с результатом\n\n- Параллельные операции"
    },
    {
      "type": "text",
      "value": "### CoroutineContext"
    },
    {
      "type": "text",
      "value": "**CoroutineContext** — это \"настройки\" или \"контекст\" корутины."
    },
    {
      "type": "text",
      "value": "**Что входит в контекст:**\n\n- **Dispatcher** - где выполнять (Main, IO, Default)\n\n- **Job** - сама задача\n\n- **CoroutineName** - имя для отладки\n\n- **ExceptionHandler** - обработчик ошибок"
    },
    {
      "type": "text",
      "value": "### Job (Задача)"
    },
    {
      "type": "text",
      "value": "- Это **ссылка** на запущенную корутину\n\n\n\n- Через **Job** можно управлять **корутиной** (отменять, ждать завершения)\n\n\n\n- Каждая корутина возвращает **Job**"
    },
    {
      "type": "text",
      "value": "**Job** — это представление корутины как \"задачи\", которой можно управлять."
    },
    {
      "type": "text",
      "value": "**Отмена Job** приведет к отмене всех дочерних Job. Это работает и в обратном порядке в случае возникновению ошибки/отмены дочерних Job."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Запускаем стирку в машинке\nval laundryJob = launch { \n    washingMachine.run() \n}\n\n// У нас есть \"пульт управления\" от машинки\nlaundryJob.cancel()    // Отменить стирку\nlaundryJob.join()      // Ждать завершения"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Родительская корутина\nval parentJob = launch {\n    // Дочерние корутины\n    launch { /* ребенок 1 */ }\n    launch { /* ребенок 2 */ }\n}\n\n// Если отменить parentJob - ВСЕ дети тоже отменятся\nparentJob.cancel() // Автоматическая отмена всех детей"
    },
    {
      "type": "text",
      "value": "fun Job.ensureActive() проверяет, активная ли текущая **Job**."
    },
    {
      "type": "text",
      "value": "### Dispatcher (Диспетчер)"
    },
    {
      "type": "text",
      "value": "**Dispatcher** — определяет где будет выполняться корутина (в каком потоке)."
    },
    {
      "type": "text",
      "value": "Хорошим тоном является **явное указание диспатчера** с помощью withContext()"
    },
    {
      "type": "text",
      "value": "**Основные диспетчеры:**"
    },
    {
      "type": "text",
      "value": "- **Dispatchers.Main** - Главный поток UI. Dыполняет работу на главном потоке. Работает только с зависимостью, где есть понятие main dispatchers. например Corutine Android."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "launch(Dispatchers.Main) {\n    textView.text = \"Обновляем UI\" // Только UI операции\n}"
    },
    {
      "type": "text",
      "value": "- **Dispatchers.IO** - Для операций ввода/вывода. Предназначен для выполнения IO операций на специальном выделено для этого пуле потоков."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "launch(Dispatchers.IO) {\n    // Сеть, база данных, файлы\n    readFromDatabase()\n    downloadFile()\n}"
    },
    {
      "type": "text",
      "value": "- **Dispatchers.Default** - Для вычислений стандартный диспатчер, который используется всеми билдерами корутин (такими как launch и acinc), если не указан другой билдер."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "launch(Dispatchers.Default) {\n    // Сортировка, математика, обработка данных\n    heavyCalculation()\n    sortLargeList()\n}"
    },
    {
      "type": "text",
      "value": "- **Dispatchers.Unconfined** - диспатчер который не привязан ни к какому потоку. Выполнение корутины происходит в том же потоке, где выполняется ее создание и запуск."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "//Job + Dispatcher в действии\nfun loadUserData() {\n    // Запускаем загрузку в фоне\n    val loadJob = viewModelScope.launch(Dispatchers.IO) {\n        val user = api.getUser()\n        \n        // Переключаемся на Main поток для UI\n        withContext(Dispatchers.Main) {\n            showUser(user) // Безопасное обновление UI\n        }\n    }\n    \n    // Можем управлять загрузкой\n    fun cancelLoading() {\n        loadJob.cancel() // Пользователь нажал \"отмена\"\n    }\n}"
    },
    {
      "type": "text",
      "value": "### CoroutineExceptionHandler"
    },
    {
      "type": "text",
      "value": "**CoroutineExceptionHandler** — это \"ловушка для ошибок\" в корутинах."
    },
    {
      "type": "text",
      "value": "- Обрабатывает **непойманные исключения** в корутинах\n\n\n\n- Как try/catch, но для всей корутины\n\n\n\n- Работает только с launch, не с async"
    },
    {
      "type": "text",
      "value": "### Channel (Каналы)"
    },
    {
      "type": "text",
      "value": "**Channel** — это способ общения между корутинами. Так же Channel поддерживают работы нескольких коорутин, и делают это безопасно."
    },
    {
      "type": "text",
      "value": "- Передает данные между корутинами\n\n- Похож на BlockingQueue из java, но не блокирует потоки\n\n- Отправитель и получатель работают асинхронно"
    },
    {
      "type": "text",
      "value": "По умолчанию канал работает пока не будет закрыт вызовом функции close."
    },
    {
      "type": "text",
      "value": "**Для работы с каналами используется:**\n\n- **SendCahnnel** - для отправки значения \n\n- **ReceiveChannel** - для получения значений. (Так же значения можно получить с помощью цикла по каналу.)"
    },
    {
      "type": "text",
      "value": "По умолчанию канал работает пока не будет закрыт вызовом функции **close**."
    },
    {
      "type": "image",
      "src": "/images/android/android_coroutine_channel.png",
      "alt": "Работа каналов в корутинах",
      "caption": "Работа каналов в корутинах"
    },
    {
      "type": "text",
      "value": "Типы каналов:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val channel = Channel<Int>() // Базовый канал\n\n// RENDEZVOUS - ждет получателя (по умолчанию)\n// BUFFERED - имеет буфер\n// UNLIMITED - бесконечный буфер\n// CONFLATED - хранит только последнее значение"
    },
    {
      "type": "text",
      "value": "### Flow (Поток)"
    },
    {
      "type": "text",
      "value": "**Flow** — это **поток данных**, который может emit (испускать) значения over time."
    },
    {
      "type": "text",
      "value": "- Как Sequence, но асинхронная\n\n- Выдает значения по мере их появления\n\n- Cold stream - начинает работать при появлении подписчика"
    },
    {
      "type": "text",
      "value": "**Особенности Flow:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// ХОЛОДНЫЙ поток - каждый collect запускает заново\nval coldFlow = flow { emit(\"Data\") }\n\n// ГОРЯЧИЙ поток - StateFlow/SharedFlow\nval hotFlow = MutableStateFlow(\"Initial\")"
    },
    {
      "type": "text",
      "value": "### SharedFlow (Общий поток)"
    },
    {
      "type": "text",
      "value": "**SharedFlow** — это \"горячий\" поток, который активно эмитит данные, независимо от наличия подписчиков."
    },
    {
      "type": "text",
      "value": "- **Горячий поток** - данные эмитятся, даже если никто не слушает\n\n- **Много подписчиков** - все получают одни и те же данные\n\n- **Без начального значения** - начинает эмитить с момента создания"
    },
    {
      "type": "text",
      "value": "**Настройки SharedFlow:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val sharedFlow = MutableSharedFlow<String>(\n    replay = 2,        // Хранит 2 последних значения для новых подписчиков\n    extraBufferCapacity = 10, // Дополнительный буфер\n    onBufferOverflow = BufferOverflow.DROP_OLDEST // Стратегия при переполнении\n)"
    },
    {
      "type": "text",
      "value": "### StateFlow (Поток состояния)"
    },
    {
      "type": "text",
      "value": "**StateFlow** — это специальный SharedFlow для управления **состоянием** приложения."
    },
    {
      "type": "text",
      "value": "- **Всегда** имеет текущее значение (не может быть пустым)\n\n- **Эмитит только при изменении** значения (distinctUntilChanged)\n\n- Идеален для **UI состояния**"
    },
    {
      "type": "text",
      "value": "**Сравнение SharedFlow vs StateFlow**\n\n- **SharedFlow** - для событий:\n\n- **StateFlow** - для состояния:"
    },
    {
      "type": "text",
      "value": "### Suspend (Приостанавливающие функции)"
    },
    {
      "type": "text",
      "value": "**Suspend** — означает \"приостанавливаемый\". Это функции, которые могут временно остановить выполнение без блокировки потока."
    },
    {
      "type": "text",
      "value": "- Функции, которые могут работать с корутинами\n\n- Могут приостанавливать выполнение и освобождать поток\n\n- Могут вызывать другие suspend-функции"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Обычная функция - как лифт, который едет без остановок\nfun normalFunction() {\n    // работает непрерывно\n}\n\n// Suspend функция - как автобус с остановками \n// Можно вызывать только из корутин или других suspend функций\nsuspend fun suspendFunction() {\n    doWork1()\n    delay(1000)        // ОСТАНОВКА - пассажиры ждут, но двигатель работает\n    doWork2()          // ПРОДОЛЖАЕМ с того же места\n}"
    }
  ]
}