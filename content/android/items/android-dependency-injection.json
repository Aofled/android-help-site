{
  "title": "Dependency Injection (Внедрение зависимости)",
  "content": [
    {
      "type": "text",
      "value": "**Dependency Injection (DI)** в Android — это методология, при которой классы **получают свои зависимости (другие объекты)**, а не создают их сами, что повышает модульность, тестируемость и переиспользование кода."
    },
    {
      "type": "text",
      "value": "Вместо того чтобы сам класс создавал нужные ему объекты, они **передаются ему извне**, например, через конструктор или сеттер. Это позволяет легко заменять реализации зависимостей, например, для тестирования, а также упрощает управление кодом, делая его более чистым и поддерживаемым."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// БЕЗ DI - объект сам создает зависимости\nclass Car {\n    private val engine = Engine() // Плохо: жесткая связка\n}\n\n// С DI - зависимости передаются извне\nclass Car(private val engine: Engine) // Хорошо: гибкая связка"
    },
    {
      "type": "text",
      "value": "**Проблемы без DI:**\n\n- **Жесткая связность** - классы тесно связаны\n\n- **Сложное тестирование** - нельзя подменить зависимости\n\n- **Повторное использование** - сложно переиспользовать код\n\n- **Управление жизненным циклом** - объекты сами управляют зависимостями"
    },
    {
      "type": "text",
      "value": "**Преимущества с DI:**\n\n- **Гибкость** - легко менять реализации\n\n\n\n- **Тестируемость** - можно использовать moxy\n\n\n\n- **Чистота кода** - разделение ответственности\n\n\n\n- **Повторное использование** - компоненты независимы"
    },
    {
      "type": "text",
      "value": "### Способы внедрения зависимостей:"
    },
    {
      "type": "text",
      "value": "#### **Constructor Injection** (через конструктор)"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class UserRepository(\n    private val apiService: ApiService,\n    private val database: UserDatabase\n) {\n    // Зависимости передаются через конструктор\n}"
    },
    {
      "type": "text",
      "value": "#### **Field Injection** (через поля)"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var userRepository: UserRepository // Внедряется фреймворком\n}"
    },
    {
      "type": "text",
      "value": "#### **Method Injection** (через методы)"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class NotificationService {\n    fun setLogger(logger: Logger) { // Зависимость через метод\n        this.logger = logger\n    }\n}"
    },
    {
      "type": "text",
      "value": "### Популярные DI-фреймворки для Android:"
    },
    {
      "type": "text",
      "value": "- **Dagger 2 / Hilt.** — официальная надстройка над Dagger для Android\n\n- **Koin** — легковесный DI-фреймворк на чистом Kotlin\n\n- **Kodein** — другой Kotlin-ориентированный фреймворк"
    },
    {
      "type": "text",
      "value": "#### Выбор фреймворка:\n\n- **Hilt** - для больших проектов, где важна производительность\n\n- **Koin** - для маленьких/средних проектов, где важна простота\n\n- **Ручной DI** - для очень маленьких проектов или обучения"
    },
    {
      "type": "text",
      "value": "**Сравнение Hilt vs Koin**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "Критерий\t        Hilt\t                Koin\nОснова\t                Dagger 2, компиляция\tPure Kotlin, runtime\nПроизводительность\tВыше (генерация кода)\tНиже (рефлексия)\nСложность\t        Выше\t                Ниже\nПоддержка\t        Официальная Google\tСообщество\nТестирование\t        Лучшая\t                Хорошая"
    }
  ]
}