{
  "title": "DataStore - современная замена SharedPreferences",
  "content": [
    {
      "type": "text",
      "value": "**DataStore** — это новое решение от Google для хранения данных, пришедшее на смену **SharedPreferences**. Он предлагает более безопасный, производительный и удобный способ работы с ключ-значение данными и поддерживает **Kotlin корутины и Flow**."
    },
    {
      "type": "text",
      "value": "### Типы DataStore:"
    },
    {
      "type": "text",
      "value": "**DataStore (Preferences DataStore)** — это как современная замена SharedPreferences. Он хранит данные в виде ключ-значение."
    },
    {
      "type": "text",
      "value": "- Аналог SharedPreferences\n\n- Хранит данные в виде ключ-значение\n\n- Не обеспечивает типобезопасность на уровне компиляции\n\n- Прост в использовании"
    },
    {
      "type": "text",
      "value": "**Proto DataStore** — это как замена для хранения сложных объектов или структур данных. Он использует **Protocol Buffers** от Google для сериализации."
    },
    {
      "type": "text",
      "value": "- Хранит данные как экземпляры пользовательских типов\n\n- Использует Protocol Buffers для сериализации\n\n- Обеспечивает полную типобезопасность\n\n- Требует больше настроек"
    },
    {
      "type": "text",
      "value": "**Лучшие практики:**\n\n- **Используйте DI** для предоставления DataStore\n\n- **Не создавайте несколько экземпляров** для одного файла\n\n- **Для UI** преобразуйте Flow в LiveData:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val userLiveData = dataStore.data.asLiveData()"
    },
    {
      "type": "text",
      "value": "- **Тестируйте** с помощью **TestDataStore**:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val testDataStore = TestDataStore()"
    },
    {
      "type": "text",
      "value": "- **Для больших данных** используйте Proto DataStore:"
    },
    {
      "type": "text",
      "value": "### Настройка проекта"
    },
    {
      "type": "text",
      "value": "Добавление зависимостей в **build.gradle (Module: app):**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "dependencies {\n    // Preferences DataStore\n    implementation \"androidx.datastore:datastore-preferences:1.0.0\"\n    \n    // Proto DataStore (опционально)\n    implementation \"androidx.datastore:datastore:1.0.0\"\n    implementation \"com.google.protobuf:protobuf-javalite:3.18.0\"\n}"
    },
    {
      "type": "text",
      "value": "### Preferences DataStore"
    },
    {
      "type": "text",
      "value": "**Тип данных:** Хранит данные как пары \"ключ-значение\". Ключи имеют тип Preferences.Key<T>, а значения — примитивные типы: Int, String, Boolean, Float, Long, Set<String>.\n\n**Схема:** Не требует предварительного объявления схемы данных.\n\n**Простота:** Легко начать использовать, особенно если вы знакомы с SharedPreferences.\n\n**Безопасность типов:** В отличие от SharedPreferences, здесь есть безопасность типов на уровне компиляции. Вы не сможете по ошибке записать строку в ключ, ожидающий целое число."
    },
    {
      "type": "text",
      "value": "**Создание DataStore:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Создание в Kotlin (используйте делегат)\nval Context.dataStore by preferencesDataStore(\n    name = \"settings\" // Имя файла\n)"
    },
    {
      "type": "text",
      "value": "**Ключи для Preferences:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Определение ключей\nobject PreferencesKeys {\n    val USER_NAME = stringPreferencesKey(\"user_name\")\n    val NOTIFICATIONS_ENABLED = booleanPreferencesKey(\"notifications_enabled\")\n    val LAST_UPDATE_TIME = longPreferencesKey(\"last_update_time\")\n}"
    },
    {
      "type": "text",
      "value": "**Запись данных:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "suspend fun saveUserName(name: String) {\n    context.dataStore.edit { preferences ->\n        preferences[PreferencesKeys.USER_NAME] = name\n    }\n}"
    },
    {
      "type": "text",
      "value": "**Чтение данных:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val userNameFlow: Flow<String> = context.dataStore.data\n    .map { preferences ->\n        preferences[PreferencesKeys.USER_NAME] ?: \"\"\n    }"
    },
    {
      "type": "text",
      "value": "### Proto DataStore"
    },
    {
      "type": "text",
      "value": "Этот тип **DataStore** хранит данные в виде экземпляров пользовательского типа данных, который вы определяете с помощью **Protocol Buffers**. Это мощная замена для хранения сложных объектов, которые раньше приходилось сериализовать в JSON или Gson и хранить в SharedPreferences или файлах."
    },
    {
      "type": "text",
      "value": "- **Тип данных:** Хранит собственные объекты, определенные вами в .proto файле.\n\n- **Схема:** Требует предварительного определения схемы данных в файле .proto.\n\n- **Производительность:** Protocol Buffers бинарно эффективнее и быстрее для парсинга, чем JSON/XML.\n\n- **Безопасность типов:** Обеспечивает строгую типобезопасность для ваших сложных структур.\n\n- **Сложность:** Требует больше начальной настройки."
    },
    {
      "type": "text",
      "value": "Определение схемы данных - создание файла **app/src/main/proto/user_prefs.proto**:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "syntax = \"proto3\";\n\noption java_package = \"com.example.app.datastore\";\noption java_multiple_files = true;\n\nmessage UserPreferences {\n    string user_name = 1;\n    bool notifications_enabled = 2;\n    int64 last_update_time = 3;\n}"
    },
    {
      "type": "text",
      "value": "**Сериализатор:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "object UserPreferencesSerializer : Serializer<UserPreferences> {\n    override val defaultValue = UserPreferences.getDefaultInstance()\n    \n    override suspend fun readFrom(input: InputStream): UserPreferences {\n        try {\n            return UserPreferences.parseFrom(input)\n        } catch (e: Exception) {\n            throw CorruptionException(\"Cannot read proto\", e)\n        }\n    }\n    \n    override suspend fun writeTo(t: UserPreferences, output: OutputStream) {\n        t.writeTo(output)\n    }\n}"
    },
    {
      "type": "text",
      "value": "**Создание Proto DataStore:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val Context.userPreferencesStore by dataStore(\n    fileName = \"user_prefs.pb\",\n    serializer = UserPreferencesSerializer\n)"
    },
    {
      "type": "text",
      "value": "**Работа с данными:**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Запись\nsuspend fun updateUserName(name: String) {\n    context.userPreferencesStore.updateData { prefs ->\n        prefs.toBuilder().setUserName(name).build()\n    }\n}\n\n// Чтение\nval userPrefsFlow: Flow<UserPreferences> = context.userPreferencesStore.data"
    },
    {
      "type": "text",
      "value": "### Миграция с SharedPreferences:"
    },
    {
      "type": "text",
      "value": "- Автоматическая миграция:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "val Context.dataStore by preferencesDataStore(\n    name = \"settings\",\n    produceMigrations = { context ->\n        listOf(SharedPreferencesMigration(\n            context,\n            \"legacy_prefs_name\" // Имя старых SharedPreferences\n        ))\n    }\n)"
    },
    {
      "type": "text",
      "value": "- Ручная миграция:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "suspend fun manualMigration() {\n    val oldPrefs = context.getSharedPreferences(\"old_prefs\", Context.MODE_PRIVATE)\n    val newData = oldPrefs.all.mapValues { (_, value) ->\n        // Преобразование значений\n        when (value) {\n            is String -> value\n            is Int -> value.toString()\n            else -> null\n        }\n    }\n    \n    context.dataStore.edit { prefs ->\n        newData.forEach { (key, value) ->\n            if (value != null) {\n                prefs[stringPreferencesKey(key)] = value\n            }\n        }\n    }\n}"
    },
    {
      "type": "text",
      "value": "### Пример использования в ViewModel:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class SettingsViewModel(\n    private val dataStore: DataStore<Preferences>\n) : ViewModel() {\n    \n    val uiState = dataStore.data\n        .map { prefs ->\n            SettingsUiState(\n                userName = prefs[PreferencesKeys.USER_NAME] ?: \"\",\n                notificationsEnabled = prefs[PreferencesKeys.NOTIFICATIONS_ENABLED] ?: false\n            )\n        }\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = SettingsUiState()\n        )\n    \n    fun updateUserName(name: String) {\n        viewModelScope.launch {\n            dataStore.edit { prefs ->\n                prefs[PreferencesKeys.USER_NAME] = name\n            }\n        }\n    }\n}"
    }
  ]
}