{
  "title": "Dagger 2 / Hilt",
  "content": [
    {
      "type": "text",
      "value": "**Hilt и Dagger 2** — это **библиотеки для внедрения зависимостей** (Dependency Injection, DI) в Android, которые помогают автоматизировать создание и управление объектами в приложении. **Dagger 2** — это мощный фреймворк, который предоставляет каркас для DI, но требует написания большего количества шаблонного кода. **Hilt** — это библиотека поверх Dagger 2, которая значительно упрощает его использование в Android за счет автоматической генерации кода и лучшей интеграции с Android-компонентами, такими как @AndroidEntryPoint."
    },
    {
      "type": "text",
      "value": "#### Основные преимущества:\n\n- **Стандартизация** - официальный фреймворк от Google\n\n- **Упрощение** - меньше бойлерплейт-кода чем в Dagger\n\n- **Интеграция с Android** - знает о жизненных циклах компонентов\n\n- **Безопасность** - проверка на этапе компиляции"
    },
    {
      "type": "text",
      "value": "### Добавление зависимостей:"
    },
    {
      "type": "text",
      "value": "**libs.versions.toml**"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "[versions]\n. . .\nhiltAndroid = \"2.57.2\"\nkts = \"2.2.20-RC-2.0.2\"\n\n\n[libraries]\n. . .\ndagger-hilt-compiler = { module = \"com.google.dagger:hilt-compiler\", version.ref = \"hiltAndroid\" }\nhilt-android = { module = \"com.google.dagger:hilt-android\", version.ref = \"hiltAndroid\" }\n\n[plugins]\n. . .\nhilt-android = { id = \"com.google.dagger.hilt.android\", version.ref = \"hiltAndroid\" }\ngoogle-devtools-ksp = { id =\"com.google.devtools.ksp\", version.ref = \"kts\" }"
    },
    {
      "type": "text",
      "value": "**Project-level** build.gradle.kts:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "plugins {\n    . . .\n    alias(libs.plugins.hilt.android) apply false\n}"
    },
    {
      "type": "text",
      "value": "**App-level** build.gradle.kts:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "plugins {\n    . . .\n    alias(libs.plugins.google.devtools.ksp)\n    alias(libs.plugins.hilt.android)\n}\n\ndependencies {\n    . . .\n    implementation(libs.hilt.android)\n    ksp (libs.dagger.hilt.compiler)\n}"
    },
    {
      "type": "text",
      "value": "**Application:**"
    },
    {
      "type": "text",
      "value": "- **Обязательная** аннотация для Application класса\n\n- Генерирует корневой компонент приложения"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "@HiltAndroidApp\nclass MyApplication : Application() {\n    // Hilt генерирует код для этого класса\n}"
    },
    {
      "type": "text",
      "value": "**@AndroidEntryPoint** — это аннотация, которая говорит Hilt: \"Этому классу нужно внедрять зависимости\". Это **точка входа** для DI."
    },
    {
      "type": "text",
      "value": "**Куда можно ставить @AndroidEntryPoint:** `Activity`, `Fragment`, `View` (в Compose или custom View), `Service`, `BroadcastReceiver`"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity()\n\n@AndroidEntryPoint  \nclass MainFragment : Fragment()\n\n@AndroidEntryPoint\nclass MyService : Service()"
    },
    {
      "type": "text",
      "value": "**@Inject** — это аннотация, которая говорит Hilt: \"Эту зависимость нужно внедрить\". Это **запрос на dependency**."
    },
    {
      "type": "text",
      "value": "#### Где использовать @Inject:\n\n- **В конструкторе** - \"Я завишу от этих объектов\""
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class UserRepository @Inject constructor(\n    private val apiService: ApiService,      // Hilt предоставит ApiService\n    private val database: UserDatabase       // Hilt предоставит UserDatabase\n) {\n    // Класс говорит: \"Мне для работы нужны apiService и database\"\n}"
    },
    {
      "type": "text",
      "value": "- **В полях** - \"Мне нужен этот объект\""
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var userRepository: UserRepository  // Hilt предоставит UserRepository\n    \n    @Inject\n    lateinit var analytics: AnalyticsService     // Hilt предоставит AnalyticsService\n}"
    },
    {
      "type": "text",
      "value": "- **В методах** - \"Вызови этот метод с зависимостью\" (редко)"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class MyClass {\n    @Inject\n    fun setup(service: MyService) {\n        // Hilt вызовет этот метод и передаст MyService\n    }\n}"
    },
    {
      "type": "text",
      "value": "#### 1. Компоненты (Components) - \"Контейнеры зависимостей\"\n\nHilt предопределяет компоненты для Android:"
    },
    {
      "type": "text",
      "value": "**Иерархия важна!** Зависимости из родительского компонента доступны в дочерних."
    },
    {
      "type": "text",
      "value": "#### 2. Scope (Области видимости) - \"Время жизни\"\n\nКаждому компоненту соответствует Scope:"
    },
    {
      "type": "text",
      "value": "**Принцип:** Зависимость не может иметь scope более короткий, чем компонент, в который она установлена."
    },
    {
      "type": "image",
      "src": "/images/android/android_dependency_injection_hilt_components.png",
      "alt": "Компоненты (Components) - \"Контейнеры зависимостей\"",
      "caption": "Компоненты (Components) - \"Контейнеры зависимостей\""
    },
    {
      "type": "text",
      "value": "#### 3. Модули (Modules) - \"Поставщики зависимостей\""
    },
    {
      "type": "text",
      "value": "Модули говорят Hilt **КАК** создавать зависимости:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "@Module\n@InstallIn(SingletonComponent::class) // ГДЕ предоставлять\nobject NetworkModule {\n    \n    @Provides\n    @Singleton  // КАК ЧАСТО создавать\n    fun provideRetrofit(): Retrofit { // ЧТО предоставлять\n        return Retrofit.Builder().build()\n    }\n}"
    },
    {
      "type": "text",
      "value": "### Типы внедрения зависимостей:"
    },
    {
      "type": "text",
      "value": "- **Constructor Injection** (предпочтительный)"
    },
    {
      "type": "text",
      "value": "**Когда использовать:** Всегда, когда возможно. Самый чистый способ."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class UserRepository @Inject constructor(\n    private val api: ApiService  // Зависимость через конструктор\n)"
    },
    {
      "type": "text",
      "value": "- **Field Injection**"
    },
    {
      "type": "text",
      "value": "**Когда использовать:** Только для Android компонентов (Activity, Fragment)."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var userRepository: UserRepository  // Прямо в поле\n}"
    },
    {
      "type": "text",
      "value": "- **Method Injection**"
    },
    {
      "type": "text",
      "value": "**Когда использовать:** Когда нужна инициализация после создания объекта."
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "class MyClass {\n    @Inject\n    fun setupDependencies(repo: UserRepository) {\n        // ...\n    }\n}"
    },
    {
      "type": "text",
      "value": "### Ключевые аннотации и их назначение:"
    },
    {
      "type": "text",
      "value": "**Обязательные:**\n\n`@HiltAndroidApp` - точка входа, создает граф зависимостей\n\n`@AndroidEntryPoint` - разрешает внедрение в Android компоненты\n\n**Для предоставления зависимостей:**\n\n`@Module` - класс, предоставляющий зависимости\n\n`@Provides` - метод, создающий зависимость\n\n`@Binds` - метод, связывающий интерфейс с реализацией\n\n`@InstallIn` - определяет компонент для модуля\n\n**Для управления временем жизни:**\n\n`@Singleton` - один экземпляр на приложение\n\n`@ActivityScoped` - один экземпляр на Activity\n\n`@FragmentScoped` - один экземпляр на Fragment\n\n**Для квалификации:**\n\n`@Qualifier` - различает зависимости одного типа"
    },
    {
      "type": "text",
      "value": "### Полный пример приложения:"
    },
    {
      "type": "text",
      "value": "#### 1. Data Layer\n\n- Эти классы **не используют Hilt напрямую**\n\n- **Hilt** будет управлять созданием AppDatabase через модуль\n\n- UserDao получается из AppDatabase, поэтому Hilt тоже управляет им"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Entity - обычная data class, никакой магии Hilt\n@Entity\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String,\n    val email: String\n)\n\n// DAO - интерфейс, Room сам генерирует реализацию\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    suspend fun getUsers(): List<User>\n    \n    @Insert\n    suspend fun insertUser(user: User)\n}\n\n// Database - абстрактный класс, Room генерирует реализацию\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n    // Hilt НЕ создает этот класс напрямую!\n    // Он создается через DatabaseModule.provideDatabase()\n}"
    },
    {
      "type": "text",
      "value": "#### 2. Network Layer"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Интерфейс для Retrofit - Retrofit сам создает реализацию\ninterface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List<User>\n}\n// Hilt НЕ создает этот интерфейс напрямую!\n// Он создается через NetworkModule.provideApiService()"
    },
    {
      "type": "text",
      "value": "#### 3. Repository"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Ключевой момент: @Inject в конструкторе!\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService,    // Hilt предоставит эту зависимость\n    private val userDao: UserDao          // Hilt предоставит эту зависимость\n) {\n    suspend fun getUsers(): List<User> {\n        val networkUsers = apiService.getUsers()  // Используем ApiService\n        userDao.insertUser(networkUsers)          // Используем UserDao\n        return userDao.getUsers()\n    }\n}\n// Когда Hilt видит @Inject constructor, он понимает:\n// \"Чтобы создать UserRepository, мне нужны ApiService и UserDao\"\n// Hilt ищет в своих модулях, как создать эти зависимости"
    },
    {
      "type": "text",
      "value": "#### 4. Modules - СЕРДЦЕ HILT"
    },
    {
      "type": "text",
      "value": "DatabaseModule:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "@Module  // Говорим Hilt: \"Этот класс содержит методы для предоставления зависимостей\"\n@InstallIn(SingletonComponent::class)  // \"Эти зависимости живут всё время работы приложения\"\nobject DatabaseModule {\n    \n    @Provides  // \"Этот метод предоставляет зависимость типа AppDatabase\"\n    @Singleton // \"Создай только ОДИН экземпляр на всё приложение\"\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        // @ApplicationContext - Hilt автоматически предоставляет Context приложения\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,  // Создаем базу данных\n            \"app.db\"\n        ).build()\n    }\n    \n    @Provides  // \"Этот метод предоставляет зависимость типа UserDao\"\n    fun provideUserDao(database: AppDatabase): UserDao {\n        // Hilt автоматически передаст AppDatabase, который мы создали выше\n        return database.userDao()  // Просто получаем DAO из базы\n    }\n    // НЕТ @Singleton на UserDao, потому что каждый вызов database.userDao() \n    // возвращает тот же самый экземпляр (это гарантирует Room)\n}"
    },
    {
      "type": "text",
      "value": "NetworkModule:"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "@Module\n@InstallIn(SingletonComponent::class)  // \"Сетевые зависимости тоже живут всё время приложения\"\nobject NetworkModule {\n    \n    @Provides\n    @Singleton  // \"Retrofit - тяжелый объект, создай его только один раз\"\n    fun provideRetrofit(): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(\"https://jsonplaceholder.typicode.com/\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n    \n    @Provides\n    fun provideApiService(retrofit: Retrofit): ApiService {\n        // Hilt автоматически передаст Retrofit, который мы создали выше\n        return retrofit.create(ApiService::class.java)  // Retrofit создает реализацию\n    }\n    // НЕТ @Singleton на ApiService, потому что retrofit.create() \n    // легковесный и может создавать новые экземпляры\n}"
    },
    {
      "type": "text",
      "value": "### 5. ViewModel"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Специальная аннотация для ViewModel вместо @AndroidEntryPoint\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository  // Hilt предоставляет UserRepository\n) : ViewModel() {\n    // Hilt создает ViewModel через специальную фабрику\n    // Это позволяет ViewModel переживать смену конфигурации\n    \n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users.asStateFlow()\n    \n    private val _isLoading = MutableStateFlow(false)\n    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()\n    \n    fun loadUsers() {\n        viewModelScope.launch {\n            _isLoading.value = true\n            try {\n                // Используем UserRepository, который предоставил Hilt\n                _users.value = userRepository.getUsers()\n            } catch (e: Exception) {\n                // Обработка ошибок\n            } finally {\n                _isLoading.value = false\n            }\n        }\n    }\n}"
    },
    {
      "type": "text",
      "value": "### 6. Activity"
    },
    {
      "type": "code",
      "language": "kotlin",
      "value": "// Ключевая аннотация: разрешаем Hilt внедрять зависимости в этот Activity\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    \n    // Hilt автоматически создает ViewModel через специальную фабрику\n    // by viewModels() - это extension из androidx.activity:activity-ktx\n    private val viewModel: UserViewModel by viewModels()\n    // Под капотом Hilt генерирует код, который создает ViewModel\n    // с правильными зависимостями (UserRepository)\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        setupObservers()\n        viewModel.loadUsers()  // Запускаем загрузку данных\n    }\n    \n    private fun setupObservers() {\n        lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                // Следим за изменением списка пользователей\n                viewModel.users.collect { users ->\n                    updateUserList(users)  // Обновляем UI\n                }\n            }\n        }\n        \n        lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                // Следим за состоянием загрузки\n                viewModel.isLoading.collect { isLoading ->\n                    progressBar.isVisible = isLoading  // Показываем/скрываем индикатор\n                }\n            }\n        }\n    }\n}"
    },
    {
      "type": "text",
      "value": "#### Полный граф зависимостей Hilt"
    },
    {
      "type": "image",
      "src": "/images/android/android_dependency_injection_hilt_example.png",
      "alt": "Визуализация работы Hilt",
      "caption": "Визуализация работы Hilt"
    },
    {
      "type": "text",
      "value": "#### Что происходит при запуске приложения:\n\n- **Старт приложения** → Hilt инициализирует SingletonComponent\n\n- **Hilt создает** Retrofit и AppDatabase (тяжелые объекты, один раз)\n\n- **При создании** UserRepository → Hilt передает ему ApiService и UserDao\n\n- **При создании** UserViewModel → Hilt передает ему UserRepository\n\n- **При открытии** MainActivity → Hilt предоставляет готовый UserViewModel\n\n\n\n#### Преимущества такого подхода:\n\n- **Тестируемость:** Можем легко подменить ApiService на мок в тестах\n\n- **Гибкость:** Если захотим сменить базу данных или API - меняем только модули\n\n- **Безопасность:** Hilt проверяет граф зависимостей на этапе компиляции\n\n- **Управление памятью:** Тяжелые объекты создаются один раз (@Singleton)"
    },
    {
      "type": "text",
      "value": "Это и есть сила Hilt - мы описываем **ЧТО** нам нужно, а Hilt разбирается **КАК** и **КОГДА** это предоставить!"
    }
  ]
}